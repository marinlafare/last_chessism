
            PART THREE: CHESSISM_API ROUTERS
            This is the third part, it contains some general helpers for the api

            


### inner_api/routers/games.py 
# chessism_api/routers/games.py

# chessism_api/routers/games.py

from fastapi.responses import JSONResponse
from fastapi import APIRouter, Body, HTTPException # <-- Added HTTPException
from typing import Dict, Any # <-- Added typing

# --- FIXED IMPORTS ---
from chessism_api.operations.games import create_games, read_game, update_player_games
from chessism_api.database.ask_db import open_async_request # <-- Fixed import
# ---

router = APIRouter()


@router.get("/{link}") # --- FIX: Removed '/games' prefix ---
async def api_read_game(link: str) -> JSONResponse:
    """
    Retrieves game information by its link.
    """
    print(f'api call for link: {link}')
    try:
        game = await read_game(link)
        if not game: # Check if game list is empty
            raise HTTPException(status_code=404, detail=f"Game with link '{link}' not found.")
        # Return the first game found (links should be unique)
        return JSONResponse(content=game[0])
    except Exception as e:
        print(f"Error fetching game {link}: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

@router.post("") # --- FIX: Changed route from "/" to "" ---
async def api_create_game(data: Dict[str, Any] = Body(...)) -> JSONResponse: # <-- Use Dict
    """
    data = {"player_name": "some_player_name"}
    
    Fetches every available game for the player_name
    formats them and inserts them into DB.
    """
    try:
        player_name = data["player_name"]
    except KeyError:
        raise HTTPException(status_code=400, detail="Payload must include 'player_name'.")
        
    congratulation = await create_games(data)
    return JSONResponse(content={"message": congratulation})


# --- NEW ENDPOINT ---
@router.post("/update")
async def api_update_player_games(data: Dict[str, Any] = Body(...)) -> JSONResponse:
    """
    data = {"player_name": "some_player_name"}
    
    Fetches games from the last recorded month to the present.
    """
    try:
        player_name = data["player_name"]
    except KeyError:
        raise HTTPException(status_code=400, detail="Payload must include 'player_name'.")
        
    message = await update_player_games(data)
    return JSONResponse(content={"message": message})



### inner_api/routers/fens.py 
#chessism_api/routers/fens.py

from fastapi import APIRouter, BackgroundTasks, Body, HTTPException
from fastapi.responses import JSONResponse

# --- FIXED IMPORTS ---
from chessism_api.operations.fens import run_fen_generation_job
# --- MODIFIED: Import new function ---
from chessism_api.database.ask_db import (
    get_top_fens, 
    get_sum_n_games, 
    get_top_fens_unscored
)
# ---
from typing import Dict, Any 

router = APIRouter()

# --- MODIFIED: Re-ordered parameters ---
# background_tasks (no default) must come BEFORE data (has default)
@router.post("/generate")
async def api_generate_fens(background_tasks: BackgroundTasks, data: Dict[str, int] = Body(...)):
    """
    Triggers a background task to generate FENs from un-processed games.
    
    Payload: {"total_games_to_process": 10000, "batch_size": 1000}
    """
    try:
        total_games = data.get("total_games_to_process", 1000000)
        batch_size = data.get("batch_size", 1000)
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid payload format.")

    print(f"Received request to generate FENs. Target: {total_games} games.")
    
    # Start the job in a background task
    background_tasks.add_task(
        run_fen_generation_job,
        total_games_to_process=total_games,
        batch_size=batch_size
    )
    
    return JSONResponse(
        status_code=202, # Accepted
        content={"message": f"Batch job started: Generating FENs for {total_games} games."}
    )

# --- FINAL FIX: Route changed to /top to avoid internal conflicts with FastAPI's path handling ---
@router.get("/top")
async def api_get_top_fens(limit: int = 20) -> JSONResponse:
    """
    Retrieves the top N FENs with the highest n_games count and formats them as a string.
    """
    if limit <= 0 or limit > 100:
        raise HTTPException(status_code=400, detail="Limit must be between 1 and 100.")
        
    top_fens = await get_top_fens(limit)
    
    if not top_fens:
        return JSONResponse(content={"message": "No FEN data available in the database."}, status_code=200)

    # Format the data into the requested string format
    output_string = ""
    for index, fen_data in enumerate(top_fens):
        line = f"{index + 1}.- n_games: {fen_data['n_games']} (FEN: {fen_data['fen']})"
        if index < len(top_fens) - 1:
            line += "\n"
        output_string += line
        
    return JSONResponse(content={"results": output_string})

# --- NEW ENDPOINT ---
@router.get("/top_unscored")
async def api_get_top_fens_unscored(limit: int = 20) -> JSONResponse:
    """
    Retrieves the top N FENs with the highest n_games count
    that have NOT yet been analyzed (score IS NULL).
    """
    if limit <= 0 or limit > 100:
        raise HTTPException(status_code=400, detail="Limit must be between 1 and 100.")
        
    top_fens = await get_top_fens_unscored(limit)
    
    if not top_fens:
        return JSONResponse(content={"message": "No unscored FEN data available in the database."}, status_code=200)

    # Format the data into the requested string format
    output_string = ""
    for index, fen_data in enumerate(top_fens):
        line = f"{index + 1}.- n_games: {fen_data['n_games']} (FEN: {fen_data['fen']})"
        if index < len(top_fens) - 1:
            line += "\n"
        output_string += line
        
    return JSONResponse(content={"results": output_string})

# --- NEW ENDPOINT ---
@router.get("/sum_n_games")
async def api_get_sum_n_games(threshold: int = 10) -> JSONResponse:
    """
    Calculates the sum of all n_games in the fen table
    where n_games is greater than the specified threshold.
    """
    if threshold < 0:
        raise HTTPException(status_code=400, detail="Threshold must be non-negative.")
        
    total_sum = await get_sum_n_games(threshold)
    
    if total_sum is None:
        total_sum = 0
        
    return JSONResponse(content={
        "threshold": threshold,
        "total_sum_n_games": total_sum
    })



### inner_api/routers/players.py 
# chessism_api/routers/players.py

from fastapi import APIRouter, HTTPException, Body, BackgroundTasks
from fastapi.responses import JSONResponse
from typing import Dict, Any

# --- UPDATED IMPORTS ---
from chessism_api.operations.players import (
    get_current_players_with_games_in_db, 
    read_player, 
    insert_player,
    create_and_store_player_stats,
    read_player_stats,
    update_stats_for_all_primary_players
)
# ---

router = APIRouter()

@router.get("/current_players")
async def api_get_current_players_with_games():
    """
    Fetches all players that have a full profile (joined != 0).
    """
    result = await get_current_players_with_games_in_db()
    return JSONResponse(content=result)

# --- RE-ORDERED: Specific routes first ---

@router.post("/update-all-stats")
async def api_update_all_stats(background_tasks: BackgroundTasks):
    """
    Triggers a long-running background task to update the stats
    for EVERY primary player in the database.
    
    Responds immediately with a "Job Started" message.
    """
    print("Received request to update all player stats.")
    background_tasks.add_task(update_stats_for_all_primary_players)
    return JSONResponse(
        status_code=202, # Accepted
        content={"message": "Batch job started: Updating stats for all primary players in the background."}
    )

@router.get("/{player_name}/stats")
async def api_get_player_stats(player_name: str) -> JSONResponse:
    """
    Fetches a player's stats from Chess.com and updates the local database.
    1. Always attempts to fetch fresh data from the Chess.com API.
    2. Saves the data to the DB (inserting or updating).
    3. Returns the fresh data.
    """
    player_name_lower = player_name.lower()
    
    print(f"Fetching fresh stats for {player_name_lower} from Chess.com...")
    try:
        # This function handles the full "fetch and upsert" logic
        new_stats_data = await create_and_store_player_stats(player_name_lower)
        
        if new_stats_data:
            print(f"Successfully fetched and upserted stats for {player_name_lower}.")
            # .model_dump() converts the Pydantic object to a dict
            return JSONResponse(content=new_stats_data.model_dump())
        else:
            # This means get_player_stats() returned None
            raise HTTPException(status_code=404, detail="Stats not found on Chess.com (or connection failed).")
            
    except Exception as e:
        print(f"Error during stats fetch for {player_name_lower}: {repr(e)}")
        raise HTTPException(status_code=500, detail="An internal error occurred while fetching stats.")


# --- RE-ORDERED: General route last ---

@router.get("/{player_name}")
async def api_get_player_profile(player_name: str) -> JSONResponse:
    """
    Fetches a player's profile.
    1. Tries to read from the local database.
    2. If not found, attempts to fetch from Chess.com and save.
    """
    # 1. Try to read from the database first
    player_data = await read_player(player_name)
    
    if player_data:
        print(f"Found player {player_name} in database.")
        return JSONResponse(content=player_data)

    # 2. If not in DB, try to fetch from Chess.com (which also saves it)
    print(f"Player {player_name} not in DB. Fetching from Chess.com...")
    try:
        new_player_data = await insert_player({"player_name": player_name})
        
        if new_player_data:
            print(f"Successfully fetched and saved {player_name}.")
            # .model_dump() converts the Pydantic object to a dict for the JSON response
            return JSONResponse(content=new_player_data.model_dump())
        else:
            # This means get_profile() returned None (e.g., ConnectTimeout or 404 from Chess.com)
            raise HTTPException(status_code=404, detail="Player not found in database or on Chess.com (or connection failed).")
            
    except Exception as e:
        print(f"Error during insert_player fetch for {player_name}: {repr(e)}")
        raise HTTPException(status_code=500, detail="An internal error occurred while fetching the player.")



### inner_api/routers/analysis.py 
# chessism_api/routers/analysis.py

from fastapi import APIRouter, BackgroundTasks, Body, HTTPException
from fastapi.responses import JSONResponse
from typing import Dict, Any

# --- NEW IMPORTS ---
from chessism_api.operations.analysis import (
    run_analysis_job,
    run_player_analysis_job
)
# ---

router = APIRouter()

@router.post("/run_job")
async def api_run_analysis_job(
    background_tasks: BackgroundTasks, 
    data: Dict[str, Any] = Body(...)
):
    """
    Triggers a background task to analyze FENs from the main database pool.
    
    Payload:
    {
        "gpu_index": 0,
        "total_fens_to_process": 100000,
        "batch_size": 100,
        "nodes_limit": 50000
    }
    """
    try:
        gpu_index = int(data["gpu_index"])
        total_fens = int(data.get("total_fens_to_process", 1000000))
        batch_size = int(data.get("batch_size", 100))
        nodes_limit = int(data.get("nodes_limit", 50000)) # Req 3
    except (KeyError, ValueError, TypeError):
        raise HTTPException(status_code=400, detail="Invalid payload. Required: 'gpu_index' (int).")

    if gpu_index not in [0, 1]:
        raise HTTPException(status_code=400, detail="'gpu_index' must be 0 or 1.")

    print(f"Received analysis job request for GPU {gpu_index}. Target: {total_fens} FENs.")
    
    # Start the job in a background task
    background_tasks.add_task(
        run_analysis_job,
        gpu_index=gpu_index,
        total_fens_to_process=total_fens,
        batch_size=batch_size,
        nodes_limit=nodes_limit
    )
    
    return JSONResponse(
        status_code=202, # Accepted
        content={
            "message": f"Batch analysis job started on GPU {gpu_index}.",
            "gpu_index": gpu_index,
            "total_fens_to_process": total_fens,
            "batch_size": batch_size,
            "nodes_limit": nodes_limit
        }
    )

@router.post("/run_player_job")
async def api_run_player_analysis_job(
    background_tasks: BackgroundTasks, 
    data: Dict[str, Any] = Body(...)
):
    """
    Triggers a background task to analyze FENs specifically from
    a single player's games.
    
    Payload:
    {
        "player_name": "hikaru",
        "gpu_index": 0,
        "total_fens_to_process": 1000,
        "batch_size": 50,
        "nodes_limit": 50000
    }
    """
    try:
        player_name = str(data["player_name"]).lower()
        gpu_index = int(data["gpu_index"])
        total_fens = int(data.get("total_fens_to_process", 100000))
        batch_size = int(data.get("batch_size", 50))
        nodes_limit = int(data.get("nodes_limit", 50000)) # Req 3
    except (KeyError, ValueError, TypeError):
        raise HTTPException(status_code=400, detail="Invalid payload. Required: 'player_name' (str) and 'gpu_index' (int).")

    if gpu_index not in [0, 1]:
        raise HTTPException(status_code=400, detail="'gpu_index' must be 0 or 1.")

    print(f"Received PLAYER analysis job request for '{player_name}' on GPU {gpu_index}.")
    
    # Start the job in a background task
    background_tasks.add_task(
        run_player_analysis_job,
        player_name=player_name,
        gpu_index=gpu_index,
        total_fens_to_process=total_fens,
        batch_size=batch_size,
        nodes_limit=nodes_limit
    )
    
    return JSONResponse(
        status_code=202, # Accepted
        content={
            "message": f"Batch player analysis job for '{player_name}' started on GPU {gpu_index}.",
            "player_name": player_name,
            "gpu_index": gpu_index,
            "total_fens_to_process": total_fens,
            "batch_size": batch_size,
            "nodes_limit": nodes_limit
        }
    )

